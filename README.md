### Интерфейс общения с букмейкерами

Приветствую Вас и предлагаю прочитать, как бы я реализовывал эту задачу

1. Проверка возможности ставки игроком.
2. Блокировка средств на счете игрока.
3. Актуализация статуса ставки (выигрыш или проигрыш).
4. Возврат средств в случае ошибки или отмены ставки.
5. Пересчет результатов в случае изменения исхода раунда.

#### Запрос на проверку возможности ставки

POST  
URL: /api/check_bet  
Пример запроса:
```
{
  "partner_id": "12345",
  "partner_player_id": "67890",
  "amount": 100,
  "bet_id": "abcde12345"
}
```
Пример ответа:
```
{
  "status": "approved",
  "message": "Stake is it possible",
  "bet_id": "abcde12345"
}
```
Обработка ошибок:
Если запрос не удался, возвращается соответствующий статус ошибки (например, 503 Service Unavailable). В случае ошибки ставку можно повторить несколько раз с интервалом.

#### Запрос на блокировку средств

POST  
URL: /api/block_funds  
Пример запроса:
```
{
  "partner_id": "12345",
  "partner_player_id": "67890",
  "amount": 100,
  "bet_id": "abcde12345"
}
```
Пример ответа:
```
{
  "status": "blocked",
  "message": "funds have been successfully blocked",
  "bet_id": "abcde12345"
}
```
Обработка ошибок:
Аналогично предыдущему запросу, если блокировка не удалась, возвращается статус ошибки.

#### Запрос на актуализацию статуса ставки

POST  
URL: /api/update_bet_status  
Пример запроса:
```
{
  "partner_id": "12345",
  "partner_player_id": "67890",
  "amount": 100,
  "bet_id": "abcde12345",
  "status": "win",
  "payout": 200
}
```
Пример ответа:
```
{
  "status": "updated",
  "message": "The bet status has been successfully updated",
  "bet_id": "abcde12345"
}
```

#### Запрос на возврат средств

POST  
URL: /api/refund  
Пример запроса:
```
{
  "partner_id": "12345",
  "partner_player_id": "67890",
  "amount": 100,
  "bet_id": "abcde12345"
}
```
Пример ответа:
```
{
  "status": "refunded",
  "message": "Funds have been refunded",
  "bet_id": "abcde12345"
}
```

#### Запрос на пересчет результатов

POST  
URL: /api/recalculate_bets  
Пример запроса:
```
{
  "round_id": "round123",
  "correct_result": "5"
}
```
Пример ответа:
```
{
  "status": "recalculated",
  "message": "The bets have been recalculated for the round123"
}
```

### Архитектура системы обработки ставок

1. Микросервисы:
   - Сервис обработки ставок: принимающий ставки, проверяющий возможность, блокирующий средства, обновляющий статусы.
   - Сервис уведомлений: отправка уведомлений клиентам о статусах ставок, выигрышах/проигрышах.
   - Сервис интеграции с букмекерами: реализующий запросы к API букмейкеров.

2. Очереди сообщений:
   - RabbitMQ или Apache Kafka, Google PubSub, Redis etc.. для асинхронной обработки и очередей сообщений, что позволяет системе масштабироваться горизонтально и справляться с большим количеством запросов. Условно пусть это будут поды в кластере k8s с горизонтальным автоскейлингом и балансировщиком нагрузки по метрикам Prometheus

3. Базы данных:
   - SQL база данных для хранения информации о ставках, игроках и результатах. ACID принцип для работы с PostgreSql. Реплицирование бд на мастер-слейв и Read Replicas, так же с возможным шардированием к примеру по имени клиента (A-M, N-Z), в случае высоких нагрузок на бд. Плюс система в зависимости от инфроструктуры можно реализовать систему кеширования, что снизит нагрузку на бд

### Риски системы в продакшне и способы их устранения

1. Ошибки при обращении к API букмейкера:
   - Использование ретраев с экспоненциальным бэк-оффом.
   - Логи ошибок и мониторинг системы для быстрого обнаружения и устранения проблем с масштабированием (ELK/Prometheus).
   Поясню на коде, что я имею ввиду под экспоненциальным бэк-оффом:

```
import axios, { AxiosResponse } from 'axios';

async function makeApiRequest(): Promise<any> {
  const maxRetries = 5;
  let initialDelay = 1;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response: AxiosResponse<any> = await performRequest();
      
      if (response.status === 200) {
        return response.data;
      } else {
        throw new Error("Error response status");
      }

    } catch (e: any) {
      console.error(`Попытка ${attempt + 1} не удалась: ${e.message}`); // Пусть это будет пока такое логирование
      const delay = (2 ** attempt) + Math.random();
      console.log(`Ждем ${delay} секунд перед следующей попыткой`);
      await delayPromise(delay);
    }
  }

  throw new Error("All attempts to execute the request have been exhausted");
}

function performRequest(): Promise<AxiosResponse<any>> {
  return axios.get('YOUR_API_ENDPOINT');
}

function delayPromise(seconds: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}

// Пример вызова функции
makeApiRequest().then(response => {
  console.log('Успешный ответ:', response);
}).catch(error => {
  console.error('Ошибка выполнения API запроса:', error.message);
});
```

2. Неправильные результаты раунда:
   - Возможность пересчета ставок на основе корректных данных.
   - Логи и уведомления для операторов системы о необходимости пересчета.

3. Высокая нагрузка на систему:
   - Масштабируемость через использование очередей сообщений.
   - Вертикальное и горизонтальное масштабирование микросервисов (насчет вертикального зависит от конкретных кейсов и метрик приложения).


### Список технологий

### 1. Языки программирования и фреймворки
- Backend:
  - NestJS (TypeScript) для построения API, для написания серверной логики и управления запросами.
- Frontend:
  - React или Vue.js для создания интерактивного клиентского приложения.

### 2. Базы данных
- Реляционные базы данных:
  - PostgreSQL для хранения информации о пользователях, ставках и etc.
- NoSQL базы данных:
  - Redis для кэширования и быстрого доступа к часто запрашиваемым данным.
  - MongoDB (тут пожалуйста не критикуйте :)))) или Elasticsearch для хранения логов и аналитических данных (например, результаты раундов). Если сильно много логов, можно рассмотреть ClickHouse с маунтом pwc на S3 или R2 cloudflare (протокол S3)

### 3. Очереди сообщений и очереди задач
- RabbitMQ или Apache Kafka для реализации очередей сообщений. Это поможет организовать асинхронную обработку заявок на ставки и уведомлений. Но, если вы хоститесь в GCP, то я бы рекомендовал Google PubSub (не нужно готовить и меньше работы девопс инженеру)

### 4. Облачные платформы и сервисы
- Amazon Web Services (AWS):
  - AWS RDS для управляемой реляционной базы данных (PostgreSQL, MySQL).
  - AWS S3 для хранения и беккапа данных.
  - AWS Эластик (забыл как куб называется в амазоне) - для условно пересчетов ставок можно создавать джобы или что-то в этом духе
  - AWS CloudWatch для мониторинга и логирования.
- Google Cloud Platform (GCP):
  - GKE конечно же для облачной инфроструктуры.
  - Google Cloud SQL для управляемых реляционных баз данных (Сам на данный момент использую в своих проектах).
  - Google Cloud Storage для хранения данных.
  - Google Pub/Sub для организации очередей сообщений как я уже ранее упомянул.
- Microsoft Azure и etc..:
  - честно скажу не пользовался, но суть та же :)

### 5. Контейнеризация и оркестрация
- Docker для контейнеризации приложений.
- Kubernetes для оркестрации контейнеров и автоматического масштабирования сервисов (тут не надо придумывать велосипед).

### 6. Управление конфигурацией и Секретами
- Kubernetes ConfigMaps и Secrets для управления конфигурацией контейнеров.

### 7. Мониторинг и логирование
- Prometheus для мониторинга и сбора метрик.
- Grafana для визуализации данных мониторинга.
- ELK Stack (Elasticsearch, Logstash, Kibana) для агрегации, анализа и визуализации логов.

### 8. CI/CD
- GitLab CI/CD или Jenkins (для более гибких пайплайнов).
- werf или skaffold в качестве утилит для билда, деплоя (skaffold погибче, werf попроще)

### 9. Безопасность
- Let's Encrypt для SSL/TLS сертификатов. (Очень просто настраивается в k8s)
- OAuth2 и JWT для аутентификации и авторизации, так же можно использовать Lucia или exspress sessions.

### Спасибо за внимание и то что дочитали до конца :)
